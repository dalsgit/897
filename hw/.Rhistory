c(25, 15, 28, 13, 36, 22, 35, 29, 15, 31, 44, 64, 42, 30, 54, 64, 34, 56, 29, 20, 39, 21), # the data elements
nrow=11,              # number of rows
ncol=2,              # number of columns
byrow = TRUE)        # fill matrix by rows "
A
"A = matrix(
c(25, 15, 28, 13, 36, 22, 35, 29, 15, 31, 44, 64, 42, 30, 54, 64, 34, 56, 29, 20, 39, 21), # the data elements
nrow=11,              # number of rows
ncol=2,              # number of columns
byrow = TRUE)        # fill matrix by rows "
A
"A = matrix(
c(1,4,3,6,2,6,8,3,3), # the data elements
nrow=3,              # number of rows
ncol=3,              # number of columns
byrow = TRUE)        # fill matrix by rows "
A
"A = matrix(
c(1,4,3,6,2,6,8,3,3), # the data elements
nrow=3,              # number of rows
ncol=3,              # number of columns
byrow = TRUE)        # fill matrix by rows "
A
A = matrix(
c(25, 15, 28, 13, 36, 22, 35, 29, 15, 31, 44, 64, 42, 30, 54, 64, 34, 56, 29, 20, 39, 21), # the data elements
nrow=11,              # number of rows
ncol=2,              # number of columns
byrow = TRUE)        # fill matrix by rows
A
colMeans(A)
cov(A)
cor(A)
A
cor(A)
A = matrix(
c(), # the data elements
nrow=3,              # number of rows
ncol=3,              # number of columns
byrow = TRUE)        # fill matrix by rows
m=c(2,3,5)
b=c(1,0,1)
bm
b`m
;
;
sdsfd
dsfadsaf
dsfadsaf
iahdsfodsajf
[';']
;
;
;
:
import matplotlib.pyplot as plt
library (ISLR)
library (MASS)
acceleration , Auto)
pairs(~ mpg + displacement + horsepower + weight +
acceleration , Auto)
identify (horsepower ,mpg ,name)
plot(horsepower ,mpg)
attach (Auto)
plot(horsepower ,mpg)
identify (horsepower ,mpg ,name)
identify (horsepower ,mpg ,name)
plot(horsepower ,mpg)
identify (horsepower ,mpg ,name)
source('C:/study/psu/git/897/hw/chap2.R', echo=TRUE)
train
install.packages("rmarkdown")
library(ISLR)
knitr::opts_chunk$set(echo = TRUE)
library(ISLR)
data("College")
set.seed (1)
trainingRows=sample (nrow(College), 100)
#train=sample (c(TRUE ,FALSE), nrow(College),rep=TRUE)
test = College[-trainingRows,]
train = College[trainingRows,]
regfit.best=regsubsets (Apps~.,data=train, nvmax =17)
library(MASS)
library(stats)
library(boot)
library (ISLR)
library(leaps)
install.packages('leaps')
library(leaps)
regfit.best=regsubsets (Apps~.,data=train, nvmax =17)
dim(train)
names(train)
train.mat=model.matrix (Apps~.,data=train)
View(train.mat)
View(train)
View(train.mat)
View(train)
val.errors =rep(NA ,17)
i=1
coefi=coef(regfit.best ,id=i)
print('For: '+coefi)
names(coefi)
pred=train.mat [,names(coefi)]%*% coefi
View(pred)
val.errors [i]= mean(( train$Apps-pred)^2)
}
for(i in 1:17) {
i=1
coefi=coef(regfit.best ,id=i)
pred=train.mat [,names(coefi)]%*% coefi
val.errors [i]= mean(( train$Apps-pred)^2)
}
dim(train)
names(train)
regfit.best=regsubsets (Apps~.,data=train, nvmax=17)
train.mat=model.matrix (Apps~.,data=train)
val.errors =rep(NA ,17)
for(i in 1:17) {
i=1
coefi=coef(regfit.best ,id=i)
pred=train.mat [,names(coefi)]%*% coefi
val.errors [i]= mean(( train$Apps-pred)^2)
}
}
dim(train)
names(train)
regfit.best=regsubsets (Apps~.,data=train, nvmax=17)
train.mat=model.matrix (Apps~.,data=train)
val.errors =rep(NA ,17)
for(i in 1:17) {
coefi=coef(regfit.best ,id=i)
pred=train.mat [,names(coefi)]%*% coefi
val.errors [i]= mean(( train$Apps-pred)^2)
}
dim(train)
names(train)
regfit.best=regsubsets (Apps~.,data=train, nvmax=17)
train.mat=model.matrix (Apps~.,data=train)
val.errors =rep(NA ,17)
for(i in 1:17) {
coefi=coef(regfit.best ,id=i)
pred=train.mat [,names(coefi)]%*% coefi
val.errors [i]= mean(( train$Apps-pred)^2)
}
plot(val.errors ,type='b')
test.mat=model.matrix (Apps~.,data=test)
val.errors =rep(NA ,17)
for(i in 1:17){
coefi=coef(regfit.best ,id=i)
pred=test.mat [,names(coefi)]%*% coefi
val.errors [i]= mean(( test$Apps-pred)^2)
}
plot(val.errors ,type='b')
plot(val.errors ,type='b', x='# of parameters')
plot(val.errors ,type='b', xlab='# of parameters')
plot(val.errors ,type='b', x=1:17, xlab='# of parameters', ylab='Training MSE')
plot(val.errors ,type='b', xlab='# of parameters', ylab='Test MSE')
dim(train)
names(train)
regfit.best=regsubsets (Apps~.,data=train, nvmax=17)
train.mat=model.matrix (Apps~.,data=train)
train.val.errors =rep(NA ,17)
for(i in 1:17) {
coefi=coef(regfit.best ,id=i)
pred=train.mat [,names(coefi)]%*% coefi
train.val.errors [i]= mean(( train$Apps-pred)^2)
}
plot(train.val.errors ,type='b', xlab='# of parameters', ylab='Training MSE')
test.mat=model.matrix (Apps~.,data=test)
test.val.errors =rep(NA ,17)
for(i in 1:17){
coefi=coef(regfit.best ,id=i)
pred=test.mat [,names(coefi)]%*% coefi
test.val.errors [i]= mean(( test$Apps-pred)^2)
}
plot(test.val.errors ,type='b', xlab='# of parameters', ylab='Test MSE')
which.min(test.val.errors)
test.mat=model.matrix (Apps~.,data=test)
test.val.errors =rep(NA ,17)
for(i in 1:17){
coefi=coef(regfit.best ,id=i)
print(coefi)
pred=test.mat [,names(coefi)]%*% coefi
test.val.errors [i]= mean(( test$Apps-pred)^2)
}
plot(test.val.errors ,type='b', xlab='# of parameters', ylab='Test MSE')
print(coefi['Intercept'])
print(coefi[Intercept])
print(coefi[,'Intercept'])
print(coefi['Intercept',])
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
beta_hat_j=rep(NA ,17)
\sqrt{\sum_{j=1} (\beta_j - \hat{\beta}_j^r)^2   }
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
sum_beta_deltas_squared=rep(NA ,17)
for(i in 1:17){
beta_hat=coef(regfit.best ,id=i)
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
sum_beta_deltas_squared=rep(NA ,17)
for(i in 1:17){
beta_hat_j=coef(regfit.best ,id=i)
beta_j[names(beta_j)]
beta_hat_j[names(beta_j)]
sum_beta_deltas_squared [i]= sqrt(sum((beta_j[names(beta_j)] - beta_hat_j[names(beta_j)])^2, na.rm = TRUE))
}
plot(sum_beta_deltas_squared, type='b')
}
plot(sum_beta_deltas_squared, type='b')
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
sum_beta_deltas_squared=rep(NA ,17)
for(i in 1:17){
beta_hat_j=coef(regfit.best ,id=i)
beta_j[names(beta_j)]
beta_hat_j[names(beta_j)]
sum_beta_deltas_squared [i]= sqrt(sum((beta_j[names(beta_j)] - beta_hat_j[names(beta_j)])^2, na.rm = TRUE))
}
plot(sum_beta_deltas_squared, type='b')
which.max(sum_beta_deltas_squared)
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
sqrt_sum_beta_deltas_squared=rep(NA ,17)
for(i in 1:17){
beta_hat_j=coef(regfit.best ,id=i)
beta_j[names(beta_j)]
beta_hat_j[names(beta_j)]
sqrt_sum_beta_deltas_squared [i]= sqrt(sum((beta_j[names(beta_j)] - beta_hat_j[names(beta_j)])^2, na.rm = TRUE))
}
plot(sqrt_sum_beta_deltas_squared, type='b')
which.max(sum_beta_deltas_squared)
dim(College)
lm.fit=lm(Apps~., data=College)
beta_j = coef(lm.fit)
beta_j
sqrt_sum_beta_deltas_squared=rep(NA ,17)
for(i in 1:17){
beta_hat_j=coef(regfit.best ,id=i)
beta_j[names(beta_j)]
beta_hat_j[names(beta_j)]
sqrt_sum_beta_deltas_squared [i]= sqrt(sum((beta_j[names(beta_j)] - beta_hat_j[names(beta_j)])^2, na.rm = TRUE))
}
plot(sqrt_sum_beta_deltas_squared, type='b')
which.max(sum_beta_deltas_squared)
plot(pr.out$x[, 1], pr.out$x[, 2], col = group, main = "PCA", xlab = "PC1", ylab = "PC2")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
spreturns = spreturns[,1:100]
dim(spreturns)
cov = cov(spreturns)
R <- cor(spreturns)
corrplot.mixed(R)
heatmaply(R)
pr.out$x[,1]-spreturns[,1]
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
spreturns = spreturns[,1:100]
dim(spreturns)
cov = cov(spreturns)
R <- cor(spreturns)
corrplot.mixed(R)
heatmaply(R)
pr.out$x[,1]-spreturns[,1]
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
setwd("C:\\study\\897\\hw")
load("hw5_spreturns.Rda")
load("hw5_spreturns.Rda")
load("hw5_spreturns.Rda")
setwd("C:\\study\\psu\\git\\897\\hw")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
#C:\\study\\psu\\git\\897\\hw   C:\\study\\897\\hw
setwd("C:\\study\\psu\\git\\897\\hw")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
spreturns = spreturns[,1:100]
dim(spreturns)
cov = cov(spreturns)
R <- cor(spreturns)
corrplot.mixed(R)
heatmaply(R)
pr.out$x[,1]-spreturns[,1]
pr.out =prcomp (spreturns , scale =TRUE)
pr.var =pr.out$sdev ^2
pve=pr.var/sum(pr.var)
plot(pve , xlab="Principal Component",
ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
plot(cumsum (pve ), xlab="Principal Component", ylab ="Cumulative Proportion of Variance Explained",
ylim=c(0,1), type='b')
plot(pr.out$x[, 1], pr.out$x[, 2], col = group, main = "PCA", xlab = "PC1", ylab = "PC2")
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
cx <- sweep(spreturns, 2, colMeans(x), "-")
cx <- sweep(spreturns, 2, colMeans(spreturns), "-")
sv <- svd(spreturns)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
pr.out =prcomp (spreturns)
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns, scale(spreturns))
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
cx <- sweep(spreturns, 2, colMeans(spreturns), "-")
sv <- svd(spreturns, scale(spreturns))
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
cx <- sweep(spreturns, 2, colMeans(spreturns), "-")
sv <- svd(spreturns)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
pr.out =prcomp (spreturns , scale =TRUE)
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns, scale(spreturns))
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
sv <- svd(cx)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
sv <- svd(spreturns)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
colMeans(x)
colMeans(spreturns)
cx <- sweep(spreturns, 2, colMeans(spreturns), "-")
cx
dim(colMeans(spreturns))
colMeans(spreturns)
View(spreturns)
cx <- sweep(spreturns, 1, colMeans(spreturns), "-")
cx
spreturns = scale(spreturns, center = TRUE, scale = TRUE)
pr.out =prcomp (spreturns)
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
#C:\\study\\psu\\git\\897\\hw   C:\\study\\897\\hw
setwd("C:\\study\\psu\\git\\897\\hw")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
colMeans(spreturns)
spreturns = spreturns[,1:100]
# Lets scale and center the spreturns object prior to PCA and SVD methods are used.
spreturns_normalized = scale(spreturns, center = TRUE, scale = TRUE)
remove(spreturns)
cov = cov(spreturns_normalized)
R <- cor(spreturns_normalized)
corrplot.mixed(R)
heatmaply(R)
pr.out =prcomp (spreturns)
pr.var =pr.out$sdev ^2
pve=pr.var/sum(pr.var)
plot(pve , xlab="Principal Component",
ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
plot(cumsum (pve ), xlab="Principal Component", ylab ="Cumulative Proportion of Variance Explained",
ylim=c(0,1), type='b')
round(pr.out$rotation[,1:2],2)
biplot(pr.out, cex=0.4)
nComp = 1
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
dim(Xhat)
R <- cor(Xhat)
corrplot.mixed(R)
heatmaply(R)
nComp = 2
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
dim(Xhat)
R <- cor(Xhat)
corrplot.mixed(R)
heatmaply(R)
round(pr.out$rotation[,1:2],2)
biplot(pr.out, cex=0.4)
Xhat = pr.out$x[,1:nComp] %*% t(pr.out$rotation[,1:nComp])
dim(Xhat)
dim(pr.out$scores)
dim(pr.out$scores[1])
pr.out$scores[1]
str(pr.out)
nComp = 1
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
pr.out$scores[1]
dim(Xhat)
R <- cor(Xhat)
R <- cov(Xhat)
nComp = 2
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
dim(Xhat)
R <- cor(Xhat)
corrplot.mixed(R)
heatmaply(R)
#C:\\study\\psu\\git\\897\\hw   C:\\study\\897\\hw
setwd("C:\\study\\psu\\git\\897\\hw")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
colMeans(spreturns)
spreturns = spreturns[,1:100]
# Lets scale and center the spreturns object prior to PCA and SVD methods are used.
spreturns_normalized = scale(spreturns, center = TRUE, scale = TRUE)
remove(spreturns)
cov = cov(spreturns_normalized)
R <- cor(spreturns_normalized)
corrplot.mixed(R)
heatmaply(R)
corrplot.mixed(R)
cov = cov(spreturns_normalized)
heatmaply(R)
View(spreturns_normalized)
pr.out =prcomp (spreturns)
pr.var =pr.out$sdev ^2
pve=pr.var/sum(pr.var)
plot(pve , xlab="Principal Component",
ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
plot(cumsum (pve ), xlab="Principal Component", ylab ="Cumulative Proportion of Variance Explained",
ylim=c(0,1), type='b')
round(pr.out$rotation[,1:2],2)
biplot(pr.out, cex=0.4)
biplot(pr.out$rotation[,1:2], cex=0.4)
nComp = 2
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
R <- cor(Xhat)
cov(Xhat)
R <- cor(Xhat)
corrplot.mixed(R)
heatmaply(R)
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns)
sv <- svd(spreturns_normalized)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns_normalized)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
sv$v[1:5, 1:5]
pc$rotation[1:5, 1:5]
pr.out$rotation[1:5, 1:5]
sv$v[1:5, 1:5] - pr.out$rotation[1:5, 1:5]
sum(sv$v[1:5, 1:5] - pr.out$rotation[1:5, 1:5])
round(sv$v[1:5, 1:5] - pr.out$rotation[1:5, 1:5])
#C:\\study\\psu\\git\\897\\hw   C:\\study\\897\\hw
setwd("C:\\study\\psu\\git\\897\\hw")
#install.packages('corrplot')
#install.packages('heatmaply')
library(heatmaply)
library(corrplot)
load("hw5_spreturns.Rda")
dim(spreturns)
colMeans(spreturns)
spreturns = spreturns[,1:100]
# Lets scale and center the spreturns object prior to PCA and SVD methods are used.
spreturns_normalized = scale(spreturns, center = TRUE, scale = TRUE)
remove(spreturns)
cov = cov(spreturns_normalized)
R <- cor(spreturns_normalized)
corrplot.mixed(R)
heatmaply(R)
pr.out =prcomp (spreturns)
pr.var =pr.out$sdev ^2
pve=pr.var/sum(pr.var)
plot(pve , xlab="Principal Component",
ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
plot(cumsum (pve ), xlab="Principal Component", ylab ="Cumulative Proportion of Variance Explained",
ylim=c(0,1), type='b')
pve
round(pr.out$rotation[,1:2],2)
biplot(pr.out, cex=0.4)
round(pr.out$rotation[,1:2],2)
nComp = 2
Xhat = pr.out$x[,1:nComp] #%*% t(pr.out$rotation[,1:nComp])
cov(Xhat)
R <- cor(Xhat)
corrplot.mixed(R)
heatmaply(R)
cov(Xhat)
round(cov(Xhat))
plot(pr.out$x[, 1], pr.out$x[, 2], main = "PCA", xlab = "PC1", ylab = "PC2")
sv <- svd(spreturns_normalized)
plot(sv$u[, 1], sv$u[, 2], main = "SVD", xlab = "U1", ylab = "U2")
sv$v[1:5, 1:5]
pr.out$rotation[1:5, 1:5]
round(sv$v[1:5, 1:5] - pr.out$rotation[1:5, 1:5])
ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
plot(pve , xlab="Principal Component", ylab="Proportion of Variance Explained", ylim=c(0,1) ,type='b')
